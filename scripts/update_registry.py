#!/usr/bin/env python3
# scripts/update_registry.py
# Automatically scans descriptor files and generates registry code

import os
import re
import glob
import sys
from pathlib import Path

# Ensure we're running from the project root
os.chdir(Path(__file__).parent.parent)

def extract_descriptors():
    """Extract all descriptors from implementation files."""
    descriptors = []
    
    # Get all .cpp files in the descriptors directory
    descriptor_files = glob.glob("src/descriptors/*.cpp")
    
    # Pattern to match standard descriptor declarations
    decl_pattern = r'DECLARE_DESCRIPTOR\((\w+),\s*(\w+),\s*"([^"]+)"\)'
    
    # Pattern to match descriptor dependencies
    dep_pattern = r'DESCRIPTOR_DEPENDENCIES\((\w+)\)\s*\{[^{]*return\s*\{([^}]*)\}\s*;\s*\}'

    # New pattern to match the Broto-Moreau macro *usage*
    brotomoreau_macro_pattern = r'REGISTER_SINGLE_BROTO_MOREAU\((\w+),\s*([a-zA-Z]),\s*(\d+)\)'
    
    # Scan all descriptor implementation files
    for file_path in sorted(descriptor_files):
        is_brotomoreau_file = os.path.basename(file_path) == "brotomoreau.cpp"
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Find all standard descriptor declarations
        for match in re.finditer(decl_pattern, content):
            name, category, description = match.groups()
            
            # Find dependencies for this descriptor
            deps = []
            # Ensure the dependency pattern targets the specific descriptor name
            specific_dep_pattern = dep_pattern.replace(r'\w+', re.escape(name))
            dep_match = re.search(specific_dep_pattern, content)

            if dep_match and dep_match.group(2).strip():
                deps_str = dep_match.group(2)
                # Parse the comma-separated list of dependencies
                deps = [d.strip(' "\'') for d in deps_str.split(',') if d.strip()] # Ensure deps are stripped and non-empty
            
            descriptors.append({
                'name': name,
                'category': category,
                'description': description.strip(),
                'dependencies': deps,
                'source_file': os.path.basename(file_path),
                'is_brotomoreau': False # Flag standard descriptors
            })

        # Find Broto-Moreau descriptors by parsing the macro usage
        if is_brotomoreau_file:
            for match in re.finditer(brotomoreau_macro_pattern, content):
                prop_name_class, prop_identifier, lag = match.groups()
                # Construct the descriptor name (e.g., ATSdm1)
                name = f"ATSd{prop_identifier}{lag}"
                
                # Avoid adding duplicates
                if not any(d['name'] == name for d in descriptors):
                    descriptors.append({
                        'name': name,
                        'category': "BrotoMoreauAutocorrelation", # Assign category
                        'description': f"Broto-Moreau Autocorrelation - {prop_name_class} - Lag {lag}", # Generate description
                        'dependencies': [], # Broto-Moreau are self-contained
                        'source_file': os.path.basename(file_path),
                        'is_brotomoreau': True # Flag Broto-Moreau descriptors
                    })

    print(f"--- Total descriptors found after scanning all files: {len(descriptors)} ---")
    return descriptors

def extract_observers():
    """Extract all observers from the common implementation."""
    observers = []
    
    # Pattern to match observer class declarations
    observer_pattern = r'class\s+(\w+)\s*:\s*public\s+Observer\s*\{'
    
    # Check in common.hpp
    with open("src/common.hpp", 'r') as f:
        content = f.read()
    
    for match in re.finditer(observer_pattern, content):
        observer_name = match.group(1)
        observers.append({
            'name': observer_name
        })
    
    # Also check descriptor files for custom observers
    for file_path in glob.glob("src/descriptors/*.cpp"):
        with open(file_path, 'r') as f:
            content = f.read()
        
        for match in re.finditer(observer_pattern, content):
            observer_name = match.group(1)
            observers.append({
                'name': observer_name,
                'source_file': os.path.basename(file_path)
            })
    
    return observers

def generate_registry_hpp(descriptors, observers):
    """Generate the registry.hpp header file."""
    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    
    # Start with the header
    output = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        "// Generated by scripts/update_registry.py",
        "",
        "#pragma once",
        "",
        "namespace desfact {",
        "",
        "// Initialize the registry - ensures all static registrations take place",
        "void initializeRegistry();",
        "",
        "} // namespace desfact",
        ""
    ]
    
    # Write to file
    with open("src/registry.hpp", 'w') as f:
        f.write("\n".join(output))
    
    # Report changes
    added = current_descriptors - prev_descriptors
    removed = prev_descriptors - current_descriptors
    
    print(f"Generated src/registry.hpp with {len(descriptors)} descriptor forward declarations")
    
    if removed:
        # Clean up any header files that might contain removed descriptor declarations
        for header_file in glob.glob("src/descriptors/*.hpp"):
            with open(header_file, 'r') as f:
                content = f.read()
            
            modified = False
            for desc_name in removed:
                # Look for class declarations of removed descriptors
                class_pattern = f"class {desc_name}Descriptor[^}}]*}}"
                if re.search(class_pattern, content, re.DOTALL):
                    content = re.sub(class_pattern, "", content, flags=re.DOTALL)
                    modified = True
                    print(f"Removed class declaration for {desc_name}Descriptor from {os.path.basename(header_file)}")
            
            if modified:
                with open(header_file, 'w') as f:
                    f.write(content)

def generate_registry_cpp(descriptors, observers):
    """Generate the registry.cpp file"""
    # Start with the header
    registry_content = [
        "// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY",
        "// Generated by scripts/update_registry.py",
        "",
        "",
        "// Include descriptor headers if necessary (or rely on forward declarations)",
        "",
        "namespace desfact {",
        ""
    ]
    
    # Add forward declarations for observer registration functions
    if observers:
        registry_content.append("// Forward declarations for observer registration functions")
        for observer in sorted(observers, key=lambda x: x['name']):
            registry_content.append(f"void register{observer['name']}();")
        registry_content.append("")
    
    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    
    # Add forward declarations for all registration functions
    registry_content.append("// Forward declarations for descriptor registration functions")
    # Sort descriptors ensuring Broto-Moreau appear correctly
    sorted_descriptors = sorted(descriptors, key=lambda x: x['name'])
    for desc in sorted_descriptors:
        # Function name format depends on how it was found
        func_name = f"register_{desc['name']}Descriptor"
        registry_content.append(f"void {func_name}();")

    registry_content.append("")
    
    # Add the initializeRegistry function
    registry_content.extend([
        "// Initialize registry - this calls all registration functions",
        "void initializeRegistry() {"
    ])
    
    # First register all observers
    if observers:
        registry_content.append("    // Register standard observers first")
        for observer in sorted(observers, key=lambda x: x['name']):
            registry_content.append(f"    register{observer['name']}();")
        registry_content.append("")
    
    # Then register all descriptors
    registry_content.append("    // Register all descriptors")
    for desc in sorted_descriptors:
        # Function name format depends on how it was found
        func_name = f"register_{desc['name']}Descriptor"
        registry_content.append(f"    {func_name}();")
    
    # Add the footer
    registry_content.extend([
        "}",
        "",
        "} // namespace desfact",
        ""
    ])
    
    # Write the updated registry file
    with open("src/registry.cpp", 'w') as f:
        f.write("\n".join(registry_content))
    
    # Report changes
    added = current_descriptors - prev_descriptors
    removed = prev_descriptors - current_descriptors
    
    print(f"Updated registry file with {len(descriptors)} descriptors and {len(observers)} observers")
    print(f"Descriptors: {', '.join(sorted([d['name'] + 'Descriptor' for d in descriptors]))}")
    print(f"Observers: {', '.join(sorted([o['name'] for o in observers]))}")
    
    if added:
        print(f"Added descriptors: {', '.join(sorted(added))}")
    if removed:
        print(f"Removed descriptors: {', '.join(sorted(removed))}")
        
        # Clean up registration functions for removed descriptors
        for desc_name in removed:
            for cpp_file in glob.glob("src/descriptors/*.cpp"):
                with open(cpp_file, 'r') as f:
                    content = f.read()
                
                # Look for the registration function
                reg_function = f"void register_{desc_name}Descriptor()"
                if reg_function in content:
                    # Remove the entire registration function
                    pattern = f"void register_{desc_name}Descriptor\\(\\)[^}}]*}}"
                    new_content = re.sub(pattern, "", content, flags=re.DOTALL)
                    
                    # Write back the cleaned content
                    with open(cpp_file, 'w') as f:
                        f.write(new_content)
                    print(f"Removed registration function for {desc_name}Descriptor from {os.path.basename(cpp_file)}")

def add_registration_functions():
    observer_reg_code = """
//==============================================================================
// OBSERVER REGISTRATION FUNCTIONS
//==============================================================================
// These functions create and register the standard observers
void registerElementCountObserver() {
    auto observer = std::make_shared<ElementCountObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}

void registerRingInfoObserver() {
    auto observer = std::make_shared<RingInfoObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}

void registerElectronegativityObserver() {
    auto observer = std::make_shared<ElectronegativityObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}
"""

    with open("src/common.cpp", 'r') as f:
        content = f.read()

    # Only insert if not already present
    if "//==============================================================================\n// OBSERVER REGISTRATION FUNCTIONS" not in content:
        # Find the start of the desfact namespace
        ns_pos = content.find("namespace desfact")
        if ns_pos == -1:
            print("Error: Could not find 'namespace desfact' in src/common.cpp")
            return

        # Find the opening brace of the namespace
        brace_pos = content.find("{", ns_pos)
        if brace_pos == -1:
            print("Error: Could not find opening brace for 'namespace desfact' in src/common.cpp")
            return

        # Insert after the opening brace and any whitespace/newlines
        insert_pos = brace_pos + 1
        while insert_pos < len(content) and content[insert_pos] in " \t\r\n":
            insert_pos += 1

        # Insert the code at insert_pos
        new_content = content[:insert_pos] + "\n" + observer_reg_code + content[insert_pos:]

        with open("src/common.cpp", 'w') as f:
            f.write(new_content)

        print("Added observer registration functions to common.cpp")

def add_registration_functions_to_descriptor_files(descriptors):
    """Add registration functions to descriptor files if they don't exist."""
    for desc in descriptors:
        cpp_file = os.path.join("src/descriptors", desc['source_file'])
        
        with open(cpp_file, 'r') as f:
            content = f.read()
            
        # Check if registration function already exists
        reg_function = f"void register_{desc['name']}Descriptor()"
        if reg_function not in content:
            # Add registration function
            reg_impl = f"""
void register_{desc['name']}Descriptor() {{
    auto descriptor = std::make_shared<{desc['name']}Descriptor>();
    auto& registry = DescriptorRegistry::getInstance();
    registry.registerDescriptor(descriptor);
}}
"""
            # Add at the end of namespace
            namespace_end = content.rfind("} // namespace desfact")
            if namespace_end != -1:
                content = content[:namespace_end] + reg_impl + "\n" + content[namespace_end:]
                
                with open(cpp_file, 'w') as f:
                    f.write(content)
                    
                print(f"Added registration function for {desc['name']}Descriptor to {desc['source_file']}")

def generate_descriptors_md(descriptors):
    """Generate the DESCRIPTORS.md documentation file."""
    output = [
        "# Available Descriptors",
        "",
        f"Total descriptors: {len(descriptors)}",
        ""
    ]

    # Group by category
    descriptors_by_category = {}
    for desc in descriptors:
        cat = desc.get('category', 'Uncategorized')
        if cat not in descriptors_by_category:
            descriptors_by_category[cat] = []
        descriptors_by_category[cat].append(desc)

    # Sort categories and descriptors within categories
    for category in sorted(descriptors_by_category.keys()):
        output.append(f"## {category}")
        output.append("")
        output.append("| Name | Description | Dependencies | Source File |")
        output.append("|---|---|---|---|")
        
        sorted_descs = sorted(descriptors_by_category[category], key=lambda x: x['name'])
        for desc in sorted_descs:
             # Adjust name based on whether it's Broto-Moreau or standard
            name_display = f"{desc['name']}Descriptor"
            deps_str = ", ".join(f"`{d}`" for d in desc.get('dependencies', [])) if desc.get('dependencies') else "None"
            output.append(f"| `{name_display}` | {desc['description']} | {deps_str} | `{desc['source_file']}` |")
        output.append("")

    with open("DESCRIPTORS.md", 'w') as f:
        f.write("\n".join(output))

    print(f"Generated DESCRIPTORS.md with documentation for {len(descriptors)} descriptors")

def get_previous_descriptors():
    """Read previous descriptors from registry.hpp if it exists."""
    prev = set()
    if os.path.exists("src/registry.hpp"):
        with open("src/registry.hpp") as f:
            for line in f:
                if line.strip().startswith("void register_") and line.strip().endswith("Descriptor();"):
                    name = line.strip().split()[1][len("register_"):-len("Descriptor();")]
                    prev.add(name)
    return prev

def extract_c_descriptors():
    """Extract descriptors from C implementation files."""
    c_descriptors = []
    
    # Get all .c files in the descriptors directory
    c_descriptor_files = glob.glob("src/descriptors/*.c")
    
    # Pattern to match C function declarations for descriptor calculations
    c_func_pattern = r'extern\s+double\s+calculate(\w+)\s*\(\s*const\s+Context\s*\*\s*context\s*,\s*GetSmilesFunc\s+getSmilesFunc\s*\)'
    
    for file_path in sorted(c_descriptor_files):
        with open(file_path, 'r') as f:
            content = f.read()
            
        # Find all C descriptor calculation functions
        for match in re.finditer(c_func_pattern, content):
            name = match.group(1)
            
            # Extract description from nearby comments if available
            description = ""
            comment_pattern = rf'//\s*{name}.*?\n(//[^\n]*)'
            comment_match = re.search(comment_pattern, content)
            if comment_match:
                description = comment_match.group(1).strip('/ \t')
            else:
                # Try to extract from function comment directly above
                preceding_lines = content[:match.start()].split('\n')[-3:]
                for line in preceding_lines:
                    if '//' in line:
                        description = line.split('//', 1)[1].strip()
                        break
            
            if not description:
                description = f"{name} Descriptor"
            
            c_descriptors.append({
                'name': name,
                'category': "C_Descriptor",
                'description': description,
                'dependencies': [],
                'source_file': os.path.basename(file_path),
                'is_c_descriptor': True
            })
    
    print(f"--- Found {len(c_descriptors)} descriptors in C implementation files ---")
    return c_descriptors

def generate_c_wrapper_file(c_descriptors):
    """Generate the C wrapper implementation file."""
    if not c_descriptors:
        return
    
    # Create the wrapper file content
    wrapper_content = [
        "// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY",
        "// Generated by scripts/update_registry.py",
        "",
        "#include \"../common.hpp\"",
        "#include \"../cregistry.h\"",
        "#include <string>",
        "",
        "// C linkage for our helper function",
        "extern \"C\" {",
        "// Helper function that maintains string lifetime",
        "static thread_local std::string tls_smiles_buffer;",
        "const char* getSmilesCFunc(const struct Context* ctx) {", 
        "    auto cpp_ctx = reinterpret_cast<const desfact::Context*>(ctx);",
        "    tls_smiles_buffer = cpp_ctx->getSmiles();",
        "    return tls_smiles_buffer.c_str();",
        "}",
        "}",
        "",
        "namespace desfact {",
        ""
    ]
    
    # Add C wrapper classes
    for desc in c_descriptors:
        name = desc['name']
        wrapper_content.extend([
            f"// --- {name} Wrapper ---",
            f"DECLARE_DESCRIPTOR({name}, C_Descriptor, \"{desc['description']}\")",
            f"DESCRIPTOR_DEPENDENCIES({name}) {{ return {{}}; }}",
            f"DescriptorResult {name}Descriptor::calculate(Context& context) const {{",
            f"    // Double cast to bypass type system - first to void*, then to the C type",
            f"    void* v_ptr = &context;",
            f"    const struct Context* c_ctx = static_cast<const struct Context*>(v_ptr);",
            f"    return calculate{name}(c_ctx, getSmilesCFunc);",
            f"}}",
            ""
        ])
    
    # Add registration functions
    for desc in c_descriptors:
        name = desc['name']
        wrapper_content.extend([
            f"void register_{name}Descriptor() {{",
            f"    auto descriptor = std::make_shared<{name}Descriptor>();",
            f"    auto& registry = DescriptorRegistry::getInstance();",
            f"    registry.registerDescriptor(descriptor);",
            f"}}",
            ""
        ])
    
    wrapper_content.extend([
        "} // namespace desfact",
        ""
    ])
    
    # Write the wrapper file
    wrapper_file_path = "src/descriptors/c_wrappers.cpp"
    with open(wrapper_file_path, 'w') as f:
        f.write("\n".join(wrapper_content))
    
    print(f"Generated C wrapper file at {wrapper_file_path}")
    
    # Add to CMakeLists.txt if not already there
    add_wrapper_to_sources("src/descriptors/c_wrappers.cpp")

def add_wrapper_to_sources(wrapper_file):
    """Add the C wrapper file to the SOURCES in CMakeLists.txt if not already there."""
    cmake_file = "CMakeLists.txt"
    
    with open(cmake_file, 'r') as f:
        content = f.read()
    
    sources_pattern = r"set\(SOURCES\s+([^)]+)\)"
    match = re.search(sources_pattern, content, re.DOTALL)
    
    if match and wrapper_file not in match.group(1):
        # Add the wrapper file to SOURCES
        new_sources = match.group(1).rstrip() + f"\n    {wrapper_file}\n"
        new_content = content.replace(match.group(0), f"set(SOURCES\n{new_sources})")
        
        with open(cmake_file, 'w') as f:
            f.write(new_content)
        
        print(f"Added {wrapper_file} to SOURCES in CMakeLists.txt")

def update_c_registry_header(c_descriptors):
    """Update the cregistry.h header file."""
    if not c_descriptors:
        return
    
    header_content = [
        "// Auto-generated C registry header - DO NOT EDIT DIRECTLY",
        "// Generated by scripts/update_registry.py",
        "#ifndef CREGISTRY_H",
        "#define CREGISTRY_H",
        "",
        "#ifdef __cplusplus",
        "extern \"C\" {",
        "#endif",
        "",
        "// Forward declaration for the Context interface",
        "struct Context;",
        "typedef struct Context Context;",
        "",
        "// Function pointer type for getting SMILES string",
        "typedef const char* (*GetSmilesFunc)(const Context*);",
        "",
        "// Helper function that will be provided by the C++ implementation",
        "const char* getSmilesCFunc(const Context* ctx);",
        "",
        "// Common interface for all C descriptors",
        "// Each descriptor must implement this function to be integrated with the C++ framework",
        ""
    ]
    
    # Add function declarations
    for desc in c_descriptors:
        name = desc['name']
        header_content.append(f"// {desc['description']}")
        header_content.append(f"double calculate{name}(const Context* context, GetSmilesFunc getSmilesFunc);")
        header_content.append("")
    
    header_content.extend([
        "#ifdef __cplusplus",
        "}",
        "#endif",
        "",
        "#endif // CREGISTRY_H"
    ])
    
    # Write the header file
    with open("src/cregistry.h", 'w') as f:
        f.write("\n".join(header_content))
    
    print("Updated src/cregistry.h header file")

def validate_c_descriptor_files(c_descriptors):
    """Validate that C descriptor files correctly implement the interface."""
    for desc in c_descriptors:
        file_path = os.path.join("src/descriptors", desc['source_file'])
        
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Check if the file includes cregistry.h
        if "#include \"../cregistry.h\"" not in content and "#include <cregistry.h>" not in content:
            print(f"WARNING: {file_path} does not include cregistry.h")
            
        # Check if file has its own typedef for GetSmilesFunc that might conflict
        if "typedef" in content and "GetSmilesFunc" in content:
            print(f"WARNING: {file_path} contains its own GetSmilesFunc typedef which may conflict with cregistry.h")
            
        # Ensure the calculateXXX function has the right signature
        func_name = f"calculate{desc['name']}"
        if func_name not in content:
            print(f"ERROR: {file_path} does not contain the expected function {func_name}")

def create_c_descriptor_template():
    """Create a template for C descriptor files."""
    template = """// Template for C descriptor implementation

#include "../cregistry.h"
#include <string.h>

// Example descriptor implementation
double calculateExampleDescriptor(const Context* context, GetSmilesFunc getSmilesFunc) {
    // Get SMILES string using the provided function
    const char* smiles = getSmilesFunc(context);
    
    // Process SMILES and calculate descriptor value
    double result = 0.0;
    
    // Simple example: return length of SMILES string
    if (smiles) {
        result = strlen(smiles);
    }
    
    return result;
}
"""
    
    with open("src/descriptors/c_descriptor_template.c", 'w') as f:
        f.write(template)
    
    print("Created C descriptor template file at src/descriptors/c_descriptor_template.c")

def fix_topological_c_file():
    """Fix the topological.c file to use the correct type signature."""
    file_path = "src/descriptors/topological.c"
    
    try:
        with open(file_path, 'r') as f:
            content = f.read()
            
        # Remove the duplicate typedef that conflicts with cregistry.h
        lines = content.split('\n')
        fixed_lines = []
        
        for line in lines:
            if "typedef struct Context Context;" in line:
                # Skip this line
                continue
            elif "typedef char* (*GetSmilesFunc)" in line or "typedef char *(*GetSmilesFunc)" in line:
                # Skip this line
                continue
            else:
                fixed_lines.append(line)
        
        # Join lines back to a string
        fixed_content = '\n'.join(fixed_lines)
        
        # Fix the double const in function calls (several patterns to catch all variants)
        fixed_content = fixed_content.replace("const const char* smiles", "const char* smiles")
        fixed_content = fixed_content.replace("const const char *smiles", "const char* smiles")
        fixed_content = fixed_content.replace("const const char * smiles", "const char* smiles")
        
        # Fix function declarations to match cregistry.h
        fixed_content = fixed_content.replace("char* smiles = getSmilesFunc(context)", 
                                             "const char* smiles = getSmilesFunc(context)")
        
        with open(file_path, 'w') as f:
            f.write(fixed_content)
            
        print(f"Fixed type signatures in {file_path}")
    except Exception as e:
        print(f"ERROR: Failed to fix {file_path}: {str(e)}")

def main():
    """Main execution function."""
    print("Scanning for descriptors...")
    descriptors = extract_descriptors()
    
    print("Scanning for C descriptors...")
    c_descriptors = extract_c_descriptors()
    
    if c_descriptors:
        print("Validating C descriptor implementations...")
        validate_c_descriptor_files(c_descriptors)
        create_c_descriptor_template()
        
        # Check if topological.c needs fixing
        topological_path = "src/descriptors/topological.c"
        if os.path.exists(topological_path):
            print("Checking topological.c file...")
            fix_topological_c_file()
    
    print("Scanning for observers...")
    observers = extract_observers()

    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    current_descriptors.update(d['name'] for d in c_descriptors)
    removed = prev_descriptors - current_descriptors

    if removed:
        print(f"\nRemoving {len(removed)} deprecated descriptors:")
        for desc_name in sorted(removed):
            print(f"  - {desc_name}Descriptor")

    print("\nAdding registration functions where missing...")
    # Filter out Broto-Moreau from this step as their registration is handled by macro
    standard_descriptors = [d for d in descriptors if not d.get('is_brotomoreau', False)]
    add_registration_functions_to_descriptor_files(standard_descriptors)

    add_registration_functions() # For observers in common.cpp
    
    print("\nUpdating C registry header...")
    update_c_registry_header(c_descriptors)
    
    print("\nGenerating C wrapper file...")
    generate_c_wrapper_file(c_descriptors)

    print("\nGenerating registry header...")
    # Include C descriptors in the registry generation
    all_descriptors = descriptors + c_descriptors
    generate_registry_hpp(all_descriptors, observers) 

    print("\nGenerating registry implementation...")
    generate_registry_cpp(all_descriptors, observers)
    
    print("\nGenerating documentation...")
    generate_descriptors_md(all_descriptors)

    # Compare with previous state and report final changes
    added = current_descriptors - prev_descriptors
    
    print("\nSummary of changes:")
    if added:
        print(f"Added descriptors ({len(added)}):")
        for desc_name in sorted(added):
            print(f"  + {desc_name}Descriptor")
    if removed:
        print(f"Removed descriptors ({len(removed)}):")
        for desc_name in sorted(removed):
            print(f"  - {desc_name}Descriptor")
    
    print(f"\nFinal count: {len(all_descriptors)} descriptors")
    print("\nRegistry update complete.")

if __name__ == "__main__":
    main()