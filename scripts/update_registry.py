#!/usr/bin/env python3
# scripts/update_registry.py
# Automatically scans descriptor files and generates registry code

import os
import re
import glob
import sys
from pathlib import Path

# Ensure we're running from the project root
os.chdir(Path(__file__).parent.parent)

def extract_descriptors():
    """Extract all descriptors from implementation files."""
    descriptors = []
    
    # Get all .cpp files in the descriptors directory
    descriptor_files = glob.glob("src/descriptors/*.cpp")
    
    # Pattern to match standard descriptor declarations
    decl_pattern = r'DECLARE_DESCRIPTOR\((\w+),\s*(\w+),\s*"([^"]+)"\)'
    
    # Pattern to match descriptor dependencies
    dep_pattern = r'DESCRIPTOR_DEPENDENCIES\((\w+)\)\s*\{[^{]*return\s*\{([^}]*)\}\s*;\s*\}'

    # New pattern to match the Broto-Moreau macro *usage*
    brotomoreau_macro_pattern = r'REGISTER_SINGLE_BROTO_MOREAU\((\w+),\s*([a-zA-Z]),\s*(\d+)\)'
    
    # Scan all descriptor implementation files
    for file_path in sorted(descriptor_files):
        is_brotomoreau_file = os.path.basename(file_path) == "brotomoreau.cpp"
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Find all standard descriptor declarations
        for match in re.finditer(decl_pattern, content):
            name, category, description = match.groups()
            
            # Find dependencies for this descriptor
            deps = []
            # Ensure the dependency pattern targets the specific descriptor name
            specific_dep_pattern = dep_pattern.replace(r'\w+', re.escape(name))
            dep_match = re.search(specific_dep_pattern, content)

            if dep_match and dep_match.group(2).strip():
                deps_str = dep_match.group(2)
                # Parse the comma-separated list of dependencies
                deps = [d.strip(' "\'') for d in deps_str.split(',') if d.strip()] # Ensure deps are stripped and non-empty
            
            descriptors.append({
                'name': name,
                'category': category,
                'description': description.strip(),
                'dependencies': deps,
                'source_file': os.path.basename(file_path),
                'is_brotomoreau': False # Flag standard descriptors
            })

        # Find Broto-Moreau descriptors by parsing the macro usage
        if is_brotomoreau_file:
            for match in re.finditer(brotomoreau_macro_pattern, content):
                prop_name_class, prop_identifier, lag = match.groups()
                # Construct the descriptor name (e.g., ATSdm1)
                name = f"ATSd{prop_identifier}{lag}"
                
                # Avoid adding duplicates
                if not any(d['name'] == name for d in descriptors):
                    descriptors.append({
                        'name': name,
                        'category': "BrotoMoreauAutocorrelation", # Assign category
                        'description': f"Broto-Moreau Autocorrelation - {prop_name_class} - Lag {lag}", # Generate description
                        'dependencies': [], # Broto-Moreau are self-contained
                        'source_file': os.path.basename(file_path),
                        'is_brotomoreau': True # Flag Broto-Moreau descriptors
                    })

    print(f"--- Total descriptors found after scanning all files: {len(descriptors)} ---")
    return descriptors

def extract_observers():
    """Extract all observers from the common implementation."""
    observers = []
    
    # Pattern to match observer class declarations
    observer_pattern = r'class\s+(\w+)\s*:\s*public\s+Observer\s*\{'
    
    # Check in common.hpp
    with open("src/common.hpp", 'r') as f:
        content = f.read()
    
    for match in re.finditer(observer_pattern, content):
        observer_name = match.group(1)
        observers.append({
            'name': observer_name
        })
    
    # Also check descriptor files for custom observers
    for file_path in glob.glob("src/descriptors/*.cpp"):
        with open(file_path, 'r') as f:
            content = f.read()
        
        for match in re.finditer(observer_pattern, content):
            observer_name = match.group(1)
            observers.append({
                'name': observer_name,
                'source_file': os.path.basename(file_path)
            })
    
    return observers

def generate_registry_hpp(descriptors, observers):
    """Generate the registry.hpp header file."""
    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    
    # Start with the header
    output = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        "// Generated by scripts/update_registry.py",
        "",
        "#pragma once",
        "",
        "namespace desfact {",
        "",
        "// Initialize the registry - ensures all static registrations take place",
        "void initializeRegistry();",
        "",
        "} // namespace desfact",
        ""
    ]
    
    # Write to file
    with open("src/registry.hpp", 'w') as f:
        f.write("\n".join(output))
    
    # Report changes
    added = current_descriptors - prev_descriptors
    removed = prev_descriptors - current_descriptors
    
    print(f"Generated src/registry.hpp with {len(descriptors)} descriptor forward declarations")
    
    if removed:
        # Clean up any header files that might contain removed descriptor declarations
        for header_file in glob.glob("src/descriptors/*.hpp"):
            with open(header_file, 'r') as f:
                content = f.read()
            
            modified = False
            for desc_name in removed:
                # Look for class declarations of removed descriptors
                class_pattern = f"class {desc_name}Descriptor[^}}]*}}"
                if re.search(class_pattern, content, re.DOTALL):
                    content = re.sub(class_pattern, "", content, flags=re.DOTALL)
                    modified = True
                    print(f"Removed class declaration for {desc_name}Descriptor from {os.path.basename(header_file)}")
            
            if modified:
                with open(header_file, 'w') as f:
                    f.write(content)

def generate_registry_cpp(descriptors, observers):
    """Generate the registry.cpp file"""
    # Start with the header
    registry_content = [
        "// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY",
        "// Generated by scripts/update_registry.py",
        "",
        "#include \"common.hpp\"",
        "",
        "// Include descriptor headers if necessary (or rely on forward declarations)",
        "",
        "namespace desfact {",
        ""
    ]
    
    # Add forward declarations for observer registration functions
    if observers:
        registry_content.append("// Forward declarations for observer registration functions")
        for observer in sorted(observers, key=lambda x: x['name']):
            registry_content.append(f"void register{observer['name']}();")
        registry_content.append("")
    
    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    
    # Add forward declarations for all registration functions
    registry_content.append("// Forward declarations for descriptor registration functions")
    # Sort descriptors ensuring Broto-Moreau appear correctly
    sorted_descriptors = sorted(descriptors, key=lambda x: x['name'])
    for desc in sorted_descriptors:
        # Function name format depends on how it was found
        func_name = f"register_{desc['name']}Descriptor"
        registry_content.append(f"void {func_name}();")

    registry_content.append("")
    
    # Add the initializeRegistry function
    registry_content.extend([
        "// Initialize registry - this calls all registration functions",
        "void initializeRegistry() {"
    ])
    
    # First register all observers
    if observers:
        registry_content.append("    // Register standard observers first")
        for observer in sorted(observers, key=lambda x: x['name']):
            registry_content.append(f"    register{observer['name']}();")
        registry_content.append("")
    
    # Then register all descriptors
    registry_content.append("    // Register all descriptors")
    for desc in sorted_descriptors:
        # Function name format depends on how it was found
        func_name = f"register_{desc['name']}Descriptor"
        registry_content.append(f"    {func_name}();")
    
    # Add the footer
    registry_content.extend([
        "}",
        "",
        "} // namespace desfact",
        ""
    ])
    
    # Write the updated registry file
    with open("src/registry.cpp", 'w') as f:
        f.write("\n".join(registry_content))
    
    # Report changes
    added = current_descriptors - prev_descriptors
    removed = prev_descriptors - current_descriptors
    
    print(f"Updated registry file with {len(descriptors)} descriptors and {len(observers)} observers")
    print(f"Descriptors: {', '.join(sorted([d['name'] + 'Descriptor' for d in descriptors]))}")
    print(f"Observers: {', '.join(sorted([o['name'] for o in observers]))}")
    
    if added:
        print(f"Added descriptors: {', '.join(sorted(added))}")
    if removed:
        print(f"Removed descriptors: {', '.join(sorted(removed))}")
        
        # Clean up registration functions for removed descriptors
        for desc_name in removed:
            for cpp_file in glob.glob("src/descriptors/*.cpp"):
                with open(cpp_file, 'r') as f:
                    content = f.read()
                
                # Look for the registration function
                reg_function = f"void register_{desc_name}Descriptor()"
                if reg_function in content:
                    # Remove the entire registration function
                    pattern = f"void register_{desc_name}Descriptor\\(\\)[^}}]*}}"
                    new_content = re.sub(pattern, "", content, flags=re.DOTALL)
                    
                    # Write back the cleaned content
                    with open(cpp_file, 'w') as f:
                        f.write(new_content)
                    print(f"Removed registration function for {desc_name}Descriptor from {os.path.basename(cpp_file)}")

def add_registration_functions():
    observer_reg_code = """
//==============================================================================
// OBSERVER REGISTRATION FUNCTIONS
//==============================================================================
// These functions create and register the standard observers
void registerElementCountObserver() {
    auto observer = std::make_shared<ElementCountObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}

void registerRingInfoObserver() {
    auto observer = std::make_shared<RingInfoObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}

void registerElectronegativityObserver() {
    auto observer = std::make_shared<ElectronegativityObserver>();
    DescriptorRegistry::getInstance().registerObserver(observer);
}
"""

    with open("src/common.cpp", 'r') as f:
        content = f.read()

    # Only insert if not already present
    if "//==============================================================================\n// OBSERVER REGISTRATION FUNCTIONS" not in content:
        # Find the start of the desfact namespace
        ns_pos = content.find("namespace desfact")
        if ns_pos == -1:
            print("Error: Could not find 'namespace desfact' in src/common.cpp")
            return

        # Find the opening brace of the namespace
        brace_pos = content.find("{", ns_pos)
        if brace_pos == -1:
            print("Error: Could not find opening brace for 'namespace desfact' in src/common.cpp")
            return

        # Insert after the opening brace and any whitespace/newlines
        insert_pos = brace_pos + 1
        while insert_pos < len(content) and content[insert_pos] in " \t\r\n":
            insert_pos += 1

        # Insert the code at insert_pos
        new_content = content[:insert_pos] + "\n" + observer_reg_code + content[insert_pos:]

        with open("src/common.cpp", 'w') as f:
            f.write(new_content)

        print("Added observer registration functions to common.cpp")

def add_registration_functions_to_descriptor_files(descriptors):
    """Add registration functions to descriptor files if they don't exist."""
    for desc in descriptors:
        cpp_file = os.path.join("src/descriptors", desc['source_file'])
        
        with open(cpp_file, 'r') as f:
            content = f.read()
            
        # Check if registration function already exists
        reg_function = f"void register_{desc['name']}Descriptor()"
        if reg_function not in content:
            # Add registration function
            reg_impl = f"""
void register_{desc['name']}Descriptor() {{
    auto descriptor = std::make_shared<{desc['name']}Descriptor>();
    auto& registry = DescriptorRegistry::getInstance();
    registry.registerDescriptor(descriptor);
}}
"""
            # Add at the end of namespace
            namespace_end = content.rfind("} // namespace desfact")
            if namespace_end != -1:
                content = content[:namespace_end] + reg_impl + "\n" + content[namespace_end:]
                
                with open(cpp_file, 'w') as f:
                    f.write(content)
                    
                print(f"Added registration function for {desc['name']}Descriptor to {desc['source_file']}")

def generate_descriptors_md(descriptors):
    """Generate the DESCRIPTORS.md documentation file."""
    output = [
        "# Available Descriptors",
        "",
        f"Total descriptors: {len(descriptors)}",
        ""
    ]

    # Group by category
    descriptors_by_category = {}
    for desc in descriptors:
        cat = desc.get('category', 'Uncategorized')
        if cat not in descriptors_by_category:
            descriptors_by_category[cat] = []
        descriptors_by_category[cat].append(desc)

    # Sort categories and descriptors within categories
    for category in sorted(descriptors_by_category.keys()):
        output.append(f"## {category}")
        output.append("")
        output.append("| Name | Description | Dependencies | Source File |")
        output.append("|---|---|---|---|")
        
        sorted_descs = sorted(descriptors_by_category[category], key=lambda x: x['name'])
        for desc in sorted_descs:
             # Adjust name based on whether it's Broto-Moreau or standard
            name_display = f"{desc['name']}Descriptor"
            deps_str = ", ".join(f"`{d}`" for d in desc.get('dependencies', [])) if desc.get('dependencies') else "None"
            output.append(f"| `{name_display}` | {desc['description']} | {deps_str} | `{desc['source_file']}` |")
        output.append("")

    with open("DESCRIPTORS.md", 'w') as f:
        f.write("\n".join(output))

    print(f"Generated DESCRIPTORS.md with documentation for {len(descriptors)} descriptors")

def get_previous_descriptors():
    """Read previous descriptors from registry.hpp if it exists."""
    prev = set()
    if os.path.exists("src/registry.hpp"):
        with open("src/registry.hpp") as f:
            for line in f:
                if line.strip().startswith("void register_") and line.strip().endswith("Descriptor();"):
                    name = line.strip().split()[1][len("register_"):-len("Descriptor();")]
                    prev.add(name)
    return prev

def main():
    """Main execution function."""
    print("Scanning for descriptors...")
    descriptors = extract_descriptors()
    
    print("Scanning for observers...")
    observers = extract_observers()

    # Get previous descriptors to track removals
    prev_descriptors = get_previous_descriptors()
    current_descriptors = set(d['name'] for d in descriptors)
    removed = prev_descriptors - current_descriptors

    if removed:
        print(f"\nRemoving {len(removed)} deprecated descriptors:")
        for desc_name in sorted(removed):
            print(f"  - {desc_name}Descriptor")

    print("\nAdding registration functions where missing...")
    # Filter out Broto-Moreau from this step as their registration is handled by macro
    standard_descriptors = [d for d in descriptors if not d.get('is_brotomoreau', False)]
    add_registration_functions_to_descriptor_files(standard_descriptors)

    add_registration_functions() # For observers in common.cpp

    print("\nGenerating registry header...")
    generate_registry_hpp(descriptors, observers) 

    print("\nGenerating registry implementation...")
    generate_registry_cpp(descriptors, observers)
    
    print("\nGenerating documentation...")
    generate_descriptors_md(descriptors)

    # Compare with previous state and report final changes
    added = current_descriptors - prev_descriptors
    
    print("\nSummary of changes:")
    if added:
        print(f"Added descriptors ({len(added)}):")
        for desc_name in sorted(added):
            print(f"  + {desc_name}Descriptor")
    if removed:
        print(f"Removed descriptors ({len(removed)}):")
        for desc_name in sorted(removed):
            print(f"  - {desc_name}Descriptor")
    
    print(f"\nFinal count: {len(descriptors)} descriptors")
    print("\nRegistry update complete.")

if __name__ == "__main__":
    main()